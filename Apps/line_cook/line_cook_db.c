/*
 * This file has been automatically generated by the WICED Smart Designer.
 * BLE device's GATT database, device configuration, function that can be used
 * to send notifications and indications.
 *
 */

// line_cook_db.c

#include "bleprofile.h"
#include "bleapp.h"
#include "gpiodriver.h"
#include "string.h"
#include "stdio.h"
#include "platform.h"
#include "line_cook_db.h"

const UINT8 gatt_database[]= // Define GATT database
{
// ***** Primary service 'Generic Access'
    //<Name>Generic Access</Name>
    //<Uuid>1800</Uuid>
    //Service handle: HDLS_GENERIC_ACCESS
    //Service UUID: UUID_SERVICE_GAP
    PRIMARY_SERVICE_UUID16 (HDLS_GENERIC_ACCESS, UUID_SERVICE_GAP),

    //<Name>Device Name</Name>
    //<Uuid>2A00</Uuid>
    CHARACTERISTIC_UUID16 (HDLC_GENERIC_ACCESS_DEVICE_NAME,
                           HDLC_GENERIC_ACCESS_DEVICE_NAME_VALUE,
                           UUID_CHARACTERISTIC_DEVICE_NAME,
                           LEGATTDB_CHAR_PROP_READ,
                           LEGATTDB_PERM_READABLE,
                           9),
    'l','i','n','e',0x2d,'c','o','o','k',

    //<Name>Appearance</Name>
    //<Uuid>2A01</Uuid>
    CHARACTERISTIC_UUID16 (HDLC_GENERIC_ACCESS_APPEARANCE,
                           HDLC_GENERIC_ACCESS_APPEARANCE_VALUE,
                           UUID_CHARACTERISTIC_APPEARANCE,
                           LEGATTDB_CHAR_PROP_READ,
                           LEGATTDB_PERM_READABLE,
                           2),
    0x00,0x00,

// ***** Primary service 'Generic Attribute'
    //<Name>Generic Attribute</Name>
    //<Uuid>1801</Uuid>
    //Service handle: HDLS_GENERIC_ATTRIBUTE
    //Service UUID: UUID_SERVICE_GATT
    PRIMARY_SERVICE_UUID16 (HDLS_GENERIC_ATTRIBUTE, UUID_SERVICE_GATT),

// ***** Primary service 'Cooking Steps'
    //<Name>Cooking Steps</Name>
    //<Uuid>39 ed a2 fc d6 94 44 8e bd 3a 78 53 9e 84 c0 2c</Uuid>
    //Service handle: HDLS_COOKING_STEPS
    //Service UUID: __UUID_COOKING_STEPS
    PRIMARY_SERVICE_UUID128 (HDLS_COOKING_STEPS, __UUID_COOKING_STEPS),

    //<Name>Cooking Step</Name>
    //<Uuid>c5 21 46 8c 74 75 40 67 b9 77 7d 24 3d 2a 81 52</Uuid>
    CHARACTERISTIC_UUID128_WRITABLE (HDLC_COOKING_STEPS_COOKING_STEP,
                           HDLC_COOKING_STEPS_COOKING_STEP_VALUE,
                           __UUID_COOKING_STEPS_COOKING_STEP,
                           LEGATTDB_CHAR_PROP_READ | LEGATTDB_CHAR_PROP_WRITE,
                           LEGATTDB_PERM_READABLE | LEGATTDB_PERM_WRITE_REQ,
                           10),
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,

    //<PresentationFormat>
    //<Format></Format>
    //<Exponent>0</Exponent>
    //<Unit></Unit>
    //<NameSpace></NameSpace>
    //<Description>0</Description>
//    CHAR_DESCRIPTOR_UUID16 (HDLD_COOKING_STEPS_COOKING_STEP_PRESENTATION_FORMAT_0,
//                            UUID_DESCRIPTOR_CHARACTERISTIC_PRESENTATION_FORMAT,
//                            LEGATTDB_PERM_READABLE,
//                            7),
//   0, BIT16_TO_8(0), , BIT16_TO_8(0),
// ***** Primary service 'Over the Range'
    //<Name>Over the Range</Name>
    //<Uuid>d1 c6 da 3d f9 fe 47 6d a0 e5 58 4b d6 c4 ed 1c</Uuid>
    //Service handle: HDLS_OVER_THE_RANGE
    //Service UUID: __UUID_OVER_THE_RANGE
    PRIMARY_SERVICE_UUID128 (HDLS_OVER_THE_RANGE, __UUID_OVER_THE_RANGE),

    //<Name>Time</Name>
    //<Uuid>c8 cd 19 93 5d a0 49 d9 bd f1 8a 6f 61 f0 1c 48</Uuid>
    CHARACTERISTIC_UUID128_WRITABLE (HDLC_OVER_THE_RANGE_TIME,
                           HDLC_OVER_THE_RANGE_TIME_VALUE,
                           __UUID_OVER_THE_RANGE_TIME,
                           LEGATTDB_CHAR_PROP_READ | LEGATTDB_CHAR_PROP_WRITE | LEGATTDB_CHAR_PROP_NOTIFY | LEGATTDB_CHAR_PROP_INDICATE,
                           LEGATTDB_PERM_READABLE | LEGATTDB_PERM_WRITE_REQ,
                           4),
    0xff,0xff,0xff,0xff,

    //<ClientConfiguration>
    //<Notification>false</Notification>
    //<Indication>false</Indication>
    CHAR_DESCRIPTOR_UUID16_WRITABLE (HDLD_OVER_THE_RANGE_TIME_CLIENT_CONFIGURATION,
                                     UUID_DESCRIPTOR_CLIENT_CHARACTERISTIC_CONFIGURATION,
                                     LEGATTDB_PERM_READABLE | LEGATTDB_PERM_WRITE_CMD | LEGATTDB_PERM_WRITE_REQ | LEGATTDB_PERM_RELIABLE_WRITE | LEGATTDB_PERM_AUTH_WRITABLE,
                                     2),
    BIT16_TO_8 (CCC_NONE),

    //<PresentationFormat>
    //<Format></Format>
    //<Exponent>0</Exponent>
    //<Unit></Unit>
    //<NameSpace></NameSpace>
    //<Description>0</Description>
//    CHAR_DESCRIPTOR_UUID16 (HDLD_OVER_THE_RANGE_TIME_PRESENTATION_FORMAT_0,
//                            UUID_DESCRIPTOR_CHARACTERISTIC_PRESENTATION_FORMAT,
//                            LEGATTDB_PERM_READABLE,
//                            7),
//    , 0, BIT16_TO_8(), , BIT16_TO_8(0),
    //<Name>Fan</Name>
    //<Uuid>a3 27 4e 7c d1 35 4f 44 bf 1d 7f 4b 09 61 5f e6</Uuid>
    CHARACTERISTIC_UUID128_WRITABLE (HDLC_OVER_THE_RANGE_FAN,
                           HDLC_OVER_THE_RANGE_FAN_VALUE,
                           __UUID_OVER_THE_RANGE_FAN,
                           LEGATTDB_CHAR_PROP_READ | LEGATTDB_CHAR_PROP_WRITE | LEGATTDB_CHAR_PROP_NOTIFY | LEGATTDB_CHAR_PROP_INDICATE,
                           LEGATTDB_PERM_READABLE | LEGATTDB_PERM_WRITE_REQ,
                           1),
    0xff,

    //<ClientConfiguration>
    //<Notification>false</Notification>
    //<Indication>false</Indication>
    CHAR_DESCRIPTOR_UUID16_WRITABLE (HDLD_OVER_THE_RANGE_FAN_CLIENT_CONFIGURATION,
                                     UUID_DESCRIPTOR_CLIENT_CHARACTERISTIC_CONFIGURATION,
                                     LEGATTDB_PERM_READABLE | LEGATTDB_PERM_WRITE_CMD | LEGATTDB_PERM_WRITE_REQ | LEGATTDB_PERM_RELIABLE_WRITE | LEGATTDB_PERM_AUTH_WRITABLE,
                                     2),
    BIT16_TO_8 (CCC_NONE),

    //<PresentationFormat>
    //<Format></Format>
    //<Exponent>0</Exponent>
    //<Unit></Unit>
    //<NameSpace></NameSpace>
    //<Description>0</Description>
//    CHAR_DESCRIPTOR_UUID16 (HDLD_OVER_THE_RANGE_FAN_PRESENTATION_FORMAT_0,
//                            UUID_DESCRIPTOR_CHARACTERISTIC_PRESENTATION_FORMAT,
//                            LEGATTDB_PERM_READABLE,
//                            7),
//    , 0, BIT16_TO_8(), , BIT16_TO_8(0),
    //<Name>Light</Name>
    //<Uuid>4f 66 25 2d be 24 41 9a 98 c2 30 11 e2 4f 8f 17</Uuid>
    CHARACTERISTIC_UUID128_WRITABLE (HDLC_OVER_THE_RANGE_LIGHT,
                           HDLC_OVER_THE_RANGE_LIGHT_VALUE,
                           __UUID_OVER_THE_RANGE_LIGHT,
                           LEGATTDB_CHAR_PROP_READ | LEGATTDB_CHAR_PROP_WRITE | LEGATTDB_CHAR_PROP_NOTIFY | LEGATTDB_CHAR_PROP_INDICATE,
                           LEGATTDB_PERM_READABLE | LEGATTDB_PERM_WRITE_REQ,
                           1),
    0xff,

    //<ClientConfiguration>
    //<Notification>false</Notification>
    //<Indication>false</Indication>
    CHAR_DESCRIPTOR_UUID16_WRITABLE (HDLD_OVER_THE_RANGE_LIGHT_CLIENT_CONFIGURATION,
                                     UUID_DESCRIPTOR_CLIENT_CHARACTERISTIC_CONFIGURATION,
                                     LEGATTDB_PERM_READABLE | LEGATTDB_PERM_WRITE_CMD | LEGATTDB_PERM_WRITE_REQ | LEGATTDB_PERM_RELIABLE_WRITE | LEGATTDB_PERM_AUTH_WRITABLE,
                                     2),
    BIT16_TO_8 (CCC_NONE),

    //<PresentationFormat>
    //<Format></Format>
    //<Exponent>0</Exponent>
    //<Unit></Unit>
    //<NameSpace></NameSpace>
    //<Description>0</Description>
//    CHAR_DESCRIPTOR_UUID16 (HDLD_OVER_THE_RANGE_LIGHT_PRESENTATION_FORMAT_0,
//                            UUID_DESCRIPTOR_CHARACTERISTIC_PRESENTATION_FORMAT,
//                            LEGATTDB_PERM_READABLE,
//                            7),
//     , 0, BIT16_TO_8(),  , BIT16_TO_8(0),
};
// Indication sent, waiting for ack
UINT8 line_cook_indication_sent = 0;
// Length of the GATT database
const UINT16 gatt_database_len = sizeof(gatt_database);
// Pointer to the bonded peer info or NULL if not bonded
__HOSTINFO *p_bonded = NULL;
// Following structure defines GPIO configuration used by the application
const BLE_PROFILE_GPIO_CFG line_cook_gpio_cfg =
{
    {
        GPIO_PIN_WP,                               // This need to be used to enable/disable NVRAM write protect
        GPIO_PIN_LED, -1, -1, -1, 
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 // Other GPIOs are not used
    },
    /*.gpio_flag =*/
    {
        GPIO_SETTINGS_WP,
        GPIO_SETTINGS_LED, 0, 0, 0, 
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
    }
};

// Main vendor specific service
UINT8 line_cook_uuid_main_vsc_service[16] = {__UUID_COOKING_STEPS};
// Indication confirmation callback
static void __indication_cfm()
{
    line_cook_indication_sent = 0;
    line_cook_indication_cfm();
}

// Registers timer. Should be called from line_cook_create()
void line_cook_reg_timer()
{
}

// Finds bonded peer in the hostinfo. On exit p_bonded points on bonded peer or NULL
__HOSTINFO *__find_bonded_peer(UINT8 *bda)
{
    int i;
    p_bonded = NULL;
    if (0 == memcmp(bda, p_hostinfo_generated->bdaddr, 6))
    {
        p_bonded = p_hostinfo_generated;
    }
    return p_bonded;
}

// initializes persistent values in the hostinfo to add bonded peer
void line_cook_add_bond(UINT8 *bda)
{
    // Find this peer among bonded peers in the p_hostinfo_generated
    if (!__find_bonded_peer(bda));
    {
        // Peer is not found. Remember new one.
        p_bonded = p_hostinfo_generated;
        memcpy(p_bonded->bdaddr, bda, 6);
    }

    // Clear persistent generated values in the hostinfo for just bonded peer

    // Set the initial value of the client configuration descriptor for value 'Time'
    p_bonded->over_the_range_time_client_configuration = 0;

    // Set the initial value of the client configuration descriptor for value 'Fan'
    p_bonded->over_the_range_fan_client_configuration = 0;

    // Set the initial value of the client configuration descriptor for value 'Light'
    p_bonded->over_the_range_light_client_configuration = 0;
}

// Prepares generated code for connection - writes persistent values from __HOSTINFO to GATT DB
void __on_connection_up()
{
    line_cook_indication_sent = 0;
    // Find this peer among bonded peers in the p_hostinfo_generated
    if (__find_bonded_peer(line_cook_remote_addr))
    {
        BLEPROFILE_DB_PDU db_pdu;

        // Write the value of the client configuration descriptor for value 'Time'
        db_pdu.len = 2;
        db_pdu.pdu[0] = p_bonded->over_the_range_time_client_configuration & 0xff;
        db_pdu.pdu[1] = (p_bonded->over_the_range_time_client_configuration >> 8) & 0xff;
        bleprofile_WriteHandle(HDLD_OVER_THE_RANGE_TIME_CLIENT_CONFIGURATION, &db_pdu);

        // Write the value of the client configuration descriptor for value 'Fan'
        db_pdu.len = 2;
        db_pdu.pdu[0] = p_bonded->over_the_range_fan_client_configuration & 0xff;
        db_pdu.pdu[1] = (p_bonded->over_the_range_fan_client_configuration >> 8) & 0xff;
        bleprofile_WriteHandle(HDLD_OVER_THE_RANGE_FAN_CLIENT_CONFIGURATION, &db_pdu);

        // Write the value of the client configuration descriptor for value 'Light'
        db_pdu.len = 2;
        db_pdu.pdu[0] = p_bonded->over_the_range_light_client_configuration & 0xff;
        db_pdu.pdu[1] = (p_bonded->over_the_range_light_client_configuration >> 8) & 0xff;
        bleprofile_WriteHandle(HDLD_OVER_THE_RANGE_LIGHT_CLIENT_CONFIGURATION, &db_pdu);
    }
}

// Updates __HOSTINFO by the value written by peer.
// Returns true if any persistent value is changed
BOOL __write_handler(UINT16 handle, int len, UINT8 *attrPtr)
{
    BOOL res = FALSE;
    if (handle == HDLC_COOKING_STEPS_COOKING_STEP_VALUE)
    {
        if (len > 10)
        {
            ble_trace2("bad length:%d handle:%04x", len, handle);
        }
        else
        {
            //call custom on_write function
            ble_trace1("write handle:%04x", handle);
            res = on_write_cooking_steps_cooking_step(len, attrPtr);
        }
    }
    if (handle == HDLC_OVER_THE_RANGE_TIME_VALUE)
    {
        if (len > 4)
        {
            ble_trace2("bad length:%d handle:%04x", len, handle);
        }
        else
        {
            //call custom on_write function
            ble_trace1("write handle:%04x", handle);
            res = on_write_over_the_range_time(len, attrPtr);
        }
    }
    if ((len == 2) && (handle == HDLD_OVER_THE_RANGE_TIME_CLIENT_CONFIGURATION))
    {
        // find this peer among bonded peers in the p_hostinfo_generated
        if (__find_bonded_peer(line_cook_remote_addr))
        {
            p_bonded->over_the_range_time_client_configuration = attrPtr[0] + (attrPtr[1] << 8);
            ble_trace2("handle:%02x val:%04x", handle, p_bonded->over_the_range_time_client_configuration);
            res = TRUE;
        }
    }
    if (handle == HDLC_OVER_THE_RANGE_FAN_VALUE)
    {
        if (len > 1)
        {
            ble_trace2("bad length:%d handle:%04x", len, handle);
        }
        else
        {
            //call custom on_write function
            ble_trace1("write handle:%04x", handle);
            res = on_write_over_the_range_fan(len, attrPtr);
        }
    }
    if ((len == 2) && (handle == HDLD_OVER_THE_RANGE_FAN_CLIENT_CONFIGURATION))
    {
        // find this peer among bonded peers in the p_hostinfo_generated
        if (__find_bonded_peer(line_cook_remote_addr))
        {
            p_bonded->over_the_range_fan_client_configuration = attrPtr[0] + (attrPtr[1] << 8);
            ble_trace2("handle:%02x val:%04x", handle, p_bonded->over_the_range_fan_client_configuration);
            res = TRUE;
        }
    }
    if (handle == HDLC_OVER_THE_RANGE_LIGHT_VALUE)
    {
        if (len > 1)
        {
            ble_trace2("bad length:%d handle:%04x", len, handle);
        }
        else
        {
            //call custom on_write function
            ble_trace1("write handle:%04x", handle);
            res = on_write_over_the_range_light(len, attrPtr);
        }
    }
    if ((len == 2) && (handle == HDLD_OVER_THE_RANGE_LIGHT_CLIENT_CONFIGURATION))
    {
        // find this peer among bonded peers in the p_hostinfo_generated
        if (__find_bonded_peer(line_cook_remote_addr))
        {
            p_bonded->over_the_range_light_client_configuration = attrPtr[0] + (attrPtr[1] << 8);
            ble_trace2("handle:%02x val:%04x", handle, p_bonded->over_the_range_light_client_configuration);
            res = TRUE;
        }
    }
    return res;
}

// It should be called when 'Device Name' is changed.
BOOL store_in_db_generic_access_device_name(UINT8* p_value, UINT8 value_len)
{
    BLEPROFILE_DB_PDU db_pdu;
    // Write value to the GATT DB
    ble_trace2("write len:%d handle:%02x", value_len, HDLC_GENERIC_ACCESS_DEVICE_NAME_VALUE);
    memcpy(&db_pdu.pdu[0], p_value, value_len);
    db_pdu.len = value_len;
    bleprofile_WriteHandle(HDLC_GENERIC_ACCESS_DEVICE_NAME_VALUE, &db_pdu);
    return TRUE;
}

// It should be called when 'Appearance' is changed.
BOOL store_in_db_generic_access_appearance(UINT8* p_value, UINT8 value_len)
{
    BLEPROFILE_DB_PDU db_pdu;
    // Write value to the GATT DB
    ble_trace2("write len:%d handle:%02x", value_len, HDLC_GENERIC_ACCESS_APPEARANCE_VALUE);
    memcpy(&db_pdu.pdu[0], p_value, value_len);
    db_pdu.len = value_len;
    bleprofile_WriteHandle(HDLC_GENERIC_ACCESS_APPEARANCE_VALUE, &db_pdu);
    return TRUE;
}

// It should be called when 'Cooking Step' is changed.
BOOL store_in_db_cooking_steps_cooking_step(UINT8* p_value, UINT8 value_len)
{
    BLEPROFILE_DB_PDU db_pdu;
    // Write value to the GATT DB
    ble_trace2("write len:%d handle:%02x", value_len, HDLC_COOKING_STEPS_COOKING_STEP_VALUE);
    memcpy(&db_pdu.pdu[0], p_value, value_len);
    db_pdu.len = value_len;
    bleprofile_WriteHandle(HDLC_COOKING_STEPS_COOKING_STEP_VALUE, &db_pdu);
    return TRUE;
}

// It should be called when 'Time' is changed.
BOOL store_in_db_over_the_range_time(UINT8* p_value, UINT8 value_len, BOOL write, BOOL notify)
{
    BLEPROFILE_DB_PDU db_pdu;
    //if write is requested
    if (write)
    {
        // Write value to the GATT DB
        ble_trace2("write len:%d handle:%02x", value_len, HDLC_OVER_THE_RANGE_TIME_VALUE);
        memcpy(&db_pdu.pdu[0], p_value, value_len);
        db_pdu.len = value_len;
        bleprofile_WriteHandle(HDLC_OVER_THE_RANGE_TIME_VALUE, &db_pdu);
    }
    // If notification is requested
    if (notify)
    {
        if (__find_bonded_peer(line_cook_remote_addr))
        {
            // Exit if notify and indicate are not configured in the Client Configuration Descriptor
            if (0 == (p_bonded->over_the_range_time_client_configuration & (CCC_NOTIFICATION | CCC_INDICATION)))
            {
                ble_trace1("don't notify handle:%02x", HDLC_OVER_THE_RANGE_TIME_VALUE);
                return TRUE;
            }
            // Just return FALSE if connection is down
            if (line_cook_connection_handle == 0)
            {
                ble_trace1("not connected handle:%02x", HDLC_OVER_THE_RANGE_TIME_VALUE);
                return FALSE;
            }
            // Just return FALSE if we are waiting for confirmation
            if (line_cook_indication_sent != 0)
            {
                ble_trace1("wait confirmation handle:%02x", HDLC_OVER_THE_RANGE_TIME_VALUE);
                return FALSE;
            }
            //if write is not requested then we did't write the value. Read it
            if (!write)
            {
                bleprofile_ReadHandle(HDLC_OVER_THE_RANGE_TIME_VALUE, &db_pdu);
            }
            // Notify property is true. If client has registered for notification
            if (p_bonded->over_the_range_time_client_configuration & CCC_NOTIFICATION)
            {
                ble_trace2("notify len:%d handle:%02x", db_pdu.len, HDLC_OVER_THE_RANGE_TIME_VALUE);
                bleprofile_sendNotification(HDLC_OVER_THE_RANGE_TIME_VALUE, (UINT8 *)db_pdu.pdu, db_pdu.len);
            }
            // Indicate property is true. If client has registered for indication,
            // We can send only one and need to wait for ack.
            else
            {
                line_cook_indication_sent = 1;
                ble_trace2("indicate len:%d handle=%02x", db_pdu.len, HDLC_OVER_THE_RANGE_TIME_VALUE);
                bleprofile_sendIndication(HDLC_OVER_THE_RANGE_TIME_VALUE, (UINT8 *)db_pdu.pdu, db_pdu.len, __indication_cfm);
            }
        }
    }
    return TRUE;
}

// It should be called when 'Fan' is changed.
BOOL store_in_db_over_the_range_fan(UINT8* p_value, UINT8 value_len, BOOL write, BOOL notify)
{
    BLEPROFILE_DB_PDU db_pdu;
    //if write is requested
    if (write)
    {
        // Write value to the GATT DB
        ble_trace2("write len:%d handle:%02x", value_len, HDLC_OVER_THE_RANGE_FAN_VALUE);
        memcpy(&db_pdu.pdu[0], p_value, value_len);
        db_pdu.len = value_len;
        bleprofile_WriteHandle(HDLC_OVER_THE_RANGE_FAN_VALUE, &db_pdu);
    }
    // If notification is requested
    if (notify)
    {
        if (__find_bonded_peer(line_cook_remote_addr))
        {
            // Exit if notify and indicate are not configured in the Client Configuration Descriptor
            if (0 == (p_bonded->over_the_range_fan_client_configuration & (CCC_NOTIFICATION | CCC_INDICATION)))
            {
                ble_trace1("don't notify handle:%02x", HDLC_OVER_THE_RANGE_FAN_VALUE);
                return TRUE;
            }
            // Just return FALSE if connection is down
            if (line_cook_connection_handle == 0)
            {
                ble_trace1("not connected handle:%02x", HDLC_OVER_THE_RANGE_FAN_VALUE);
                return FALSE;
            }
            // Just return FALSE if we are waiting for confirmation
            if (line_cook_indication_sent != 0)
            {
                ble_trace1("wait confirmation handle:%02x", HDLC_OVER_THE_RANGE_FAN_VALUE);
                return FALSE;
            }
            //if write is not requested then we did't write the value. Read it
            if (!write)
            {
                bleprofile_ReadHandle(HDLC_OVER_THE_RANGE_FAN_VALUE, &db_pdu);
            }
            // Notify property is true. If client has registered for notification
            if (p_bonded->over_the_range_fan_client_configuration & CCC_NOTIFICATION)
            {
                ble_trace2("notify len:%d handle:%02x", db_pdu.len, HDLC_OVER_THE_RANGE_FAN_VALUE);
                bleprofile_sendNotification(HDLC_OVER_THE_RANGE_FAN_VALUE, (UINT8 *)db_pdu.pdu, db_pdu.len);
            }
            // Indicate property is true. If client has registered for indication,
            // We can send only one and need to wait for ack.
            else
            {
                line_cook_indication_sent = 1;
                ble_trace2("indicate len:%d handle=%02x", db_pdu.len, HDLC_OVER_THE_RANGE_FAN_VALUE);
                bleprofile_sendIndication(HDLC_OVER_THE_RANGE_FAN_VALUE, (UINT8 *)db_pdu.pdu, db_pdu.len, __indication_cfm);
            }
        }
    }
    return TRUE;
}

// It should be called when 'Light' is changed.
BOOL store_in_db_over_the_range_light(UINT8* p_value, UINT8 value_len, BOOL write, BOOL notify)
{
    BLEPROFILE_DB_PDU db_pdu;
    //if write is requested
    if (write)
    {
        // Write value to the GATT DB
        ble_trace2("write len:%d handle:%02x", value_len, HDLC_OVER_THE_RANGE_LIGHT_VALUE);
        memcpy(&db_pdu.pdu[0], p_value, value_len);
        db_pdu.len = value_len;
        bleprofile_WriteHandle(HDLC_OVER_THE_RANGE_LIGHT_VALUE, &db_pdu);
    }
    // If notification is requested
    if (notify)
    {
        if (__find_bonded_peer(line_cook_remote_addr))
        {
            // Exit if notify and indicate are not configured in the Client Configuration Descriptor
            if (0 == (p_bonded->over_the_range_light_client_configuration & (CCC_NOTIFICATION | CCC_INDICATION)))
            {
                ble_trace1("don't notify handle:%02x", HDLC_OVER_THE_RANGE_LIGHT_VALUE);
                return TRUE;
            }
            // Just return FALSE if connection is down
            if (line_cook_connection_handle == 0)
            {
                ble_trace1("not connected handle:%02x", HDLC_OVER_THE_RANGE_LIGHT_VALUE);
                return FALSE;
            }
            // Just return FALSE if we are waiting for confirmation
            if (line_cook_indication_sent != 0)
            {
                ble_trace1("wait confirmation handle:%02x", HDLC_OVER_THE_RANGE_LIGHT_VALUE);
                return FALSE;
            }
            //if write is not requested then we did't write the value. Read it
            if (!write)
            {
                bleprofile_ReadHandle(HDLC_OVER_THE_RANGE_LIGHT_VALUE, &db_pdu);
            }
            // Notify property is true. If client has registered for notification
            if (p_bonded->over_the_range_light_client_configuration & CCC_NOTIFICATION)
            {
                ble_trace2("notify len:%d handle:%02x", db_pdu.len, HDLC_OVER_THE_RANGE_LIGHT_VALUE);
                bleprofile_sendNotification(HDLC_OVER_THE_RANGE_LIGHT_VALUE, (UINT8 *)db_pdu.pdu, db_pdu.len);
            }
            // Indicate property is true. If client has registered for indication,
            // We can send only one and need to wait for ack.
            else
            {
                line_cook_indication_sent = 1;
                ble_trace2("indicate len:%d handle=%02x", db_pdu.len, HDLC_OVER_THE_RANGE_LIGHT_VALUE);
                bleprofile_sendIndication(HDLC_OVER_THE_RANGE_LIGHT_VALUE, (UINT8 *)db_pdu.pdu, db_pdu.len, __indication_cfm);
            }
        }
    }
    return TRUE;
}

